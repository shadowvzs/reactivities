// we use class library, web api and solution

// check availaible templates for dot net cli
dotnet new -h

// create new solution file - file name will be same than the parent folder name
// its like a container for dotnet application
dotnet new sln

// create class library with name, this create folder and files into Domain folder
// ex: Domain.csproj, Class1.cs, obj folder)
// each project have his own csproj file (obj folder used when project will be built)
dotnet new classlib -n Domain

dotnet new classlib -n Application
dotnet new classlib -n Persistence

// we create web api 
dotnet new webapi -n API

// check the options like: 
// add <project_path> - add/insert one or more project into solution
// list - list all projects in a solution file
// remove <project_path> - remove on or more project from the solution file
dotnet sln -h

// add Domain project into main solution
dotnet sln add Domain/
dotnet sln add Application/
dotnet sln add Persistence/
dotnet sln add API/

// we list in terminal which projects was added (ex. first row: Domain/Domain.csproj)
dotnet sln list

// lets make dependencies, ex. Applicaiton depend on Domain project
cd Application/
dotnet add reference ../Domain/
// Application project must depend also on Persistence project
dotnet add reference ../Persistence/

// we make Api depend on Application and indirectly this way we depend on Domain too
cd ..
cd API/
dotnet add reference ../Application/

// persistence project also depend on domain project
cd ..
cd Persistence
dotnet add reference ../Domain/

// Note 1: -csproj files
// csproj file contain:
// - the required dotnet version (ex. netstandard2.0 or netcoreapp3.1)
// - project reference dependencies
// - on which was built (ex. <Project Sdk="Microsoft.NET.Sdk"> or <Project Sdk="Microsoft.NET.Sdk.Web">)


// Note 2: - VSC exclude
// in visual studio code we should add the bin/obj folders into exclude 
// File/Preferences/Settings/exclude (in searchbar) and add **/bin and **/obj

// Note 3: - Program.cs
// API/Program.cs - Main handle the web api part with the routes 
// it will call CreateHostBuilder(args).Build().Run() - IHostBuilder interface
// - load json files with the configuration
// - use the kestrel web server
// - use the StartUp class (it is in same folder, StartUp.cs), we can inject here our configuration
// - ConfigureServices is the dependency injection container
// - Configure method is used for configure the HTTP request pipeline, like we can add middlewate (so ordering important here)
//      - example UseHttpsRedirection should redirect http to https - this should be commented out in our case
//      - ACTION: comment out UseHttpsRedirection
//                 - UseRouting is for middleware and UseAuthorization for auth, UseEndPoints is controller endpoints maping

// Note 4: - launchSettings
// API/Properties/launchSettings.json tell which url use the web api endpoints (http and https)
// ex. "applicationUrl": "https://localhost:5001;http://localhost:5000",
// ACTION: we remove our https endpoint

// Note 5: - Controllers
// by default we got an example controller in API/Controllers/WeatherForecastController.cs
// ACTION: we delete this controller: API/Controllers/WeatherForecastController.cs and Api/WeatherForecast.cs
// Action: create new file into API/Controllers - ValuesController.cs and copy pasted a base (base_ctrl.txt)
// [Route("api/[controller]")] - create a new route and [controller] part replaced with controller name ex. api/values
// [HttpGet] method decorator and the decorated method will handle the  api/values url request
// [HttpGet("{id}")] will match the methods like api/values/5 and in method the param name is id
//          ex: public ActionResult<string> Get(int id) { return "something string"; }
// return an array of string should be:
//                 return  new string[] { "value1", "value2" };

// NOTE!!: We use ControllerBase and not Controller for extend our controller because ControllBase not have view support unlike Controller have

// run a specific project, and we should check this in browser: http://localhost:5000/api/values
dotnet run -p API/


// Note 1: Domain class
// rename Domain/Class1.cs to Value.cs (rename the class to in the file)
// file the Value.cs with properties like id and name

// Note 2: Data Context - road to entity framework
// in Persistence folder we rename the class file and class name to DataContext

// Note 3: Add entity framework
// ctrl + shift + p in vsc (if nuget package manager plugin is installed) 
// select nuget add package
// package name is (both must have same version):
//   - Microsoft.EntityFrameworkCore.Core
//   - Microsoft.EntityFrameworkCore.Design
//   - Microsoft.EntityFrameworkCore.Sqlite
// select Persistence.csproj

// Note 4: EntityFramework need higher .net dependency
// change netstandard2.0 in Persistence.csproj to netstandard2.1

// check dependency
dotnet restore

// this tell to us we need same version (2.1) dependency in Domain.csproj and in Application.csproj too

// check dependency
dotnet restore

// Note 5: add EFCore into DataContext
// add "using Microsoft.EntityFrameworkCore;" to DataContext.cs
// then we start work on this file ( add constructor, db options)

// public DataContext(DbContextOptions options) : base(options) - copnstructor which use the base constructor
// public DbSet<Value> Values { get; set; }
//  - Value is entity (also need import with using the project where is the entity like "using Domain;")
//  - Values - will be table name

// Note 6: Service injection into service container
// in API/startup.cs - ConfigureServices we must add our DbContext above service.AddControllers();
//            service.AddDbContext<DataContext>(opt => 
//            {
//                // we inject our connection string from the configuration what we have in Startup method
//                opt.UseSqlite(Configuration.GetConnectionString("DefaultConnection"));
//            });
// we must import it from the Persistence project and Microsoft.EntityFrameworkCore

// Note 7: Connection string
// we can specify the ConnectionStrings in API/appsettings.json
// something like this for Sqlite:
//    "ConnectionStrings": {
//        "DefaultConnection": "Data source=reactivities.db"
//    },

// install dotnet entity framework globally
dotnet tool install --global dotnet-ef
// or local install
dotnet new tool-manifest
dotnet tool install --local dotnet-ef
// dotnet tool install --global dotnet-ef --version 3.1.2

// test the installed version
dotnet ef

// we create a initial migration with name InitialCreate (will be in Persistence/Migrations/20200217202915_InitialCreate.cs)
// also we must set with -p the dataContext project (Persistence)
// and the startup project (API/)
dotnet ef migrations add InitialCreate -p Persistence/ -s API/

// Note 1: table creation rule
// entity framework is convention base, so if i declared id then that will be automatical primary key with auto increment
// the table name (we get it from Persistence/DataContext - DbSet) 
// columns are based on Domain/Value.cs (because we used -p Persistence/ and DataContext is the glue between entities and final table)

// get the entity framework options
dotnet ef -h
dotnet ef database -h

// we should update database with: dotnet ef database update
// but we want make it during every program start so we will add into Program.cs

// Note 1: create scope into method
// the example below will be cleaned up instantly the main function will be done
// this will need Microsoft.Extensions.DependencyInjection;
// using (var scope = host.Services.CreateScope()) { ... }

// Note 2: Create/Update database at project start
// API/Program.cs we create a new var into Main()  and we can use Run() later
// var host = CreateHostBuilder(args).Build(); 

// !!! Note 3: watch run and restriction !!!
// watch run work only if we are in startup project 
dotnet watch run

// Note 3: Debug Sqlite with vsc (sqlite extension)
// ctrl+shift+p (view -> command pallette)
// sqlite -> open database and select database
// then we will have in left sidepanel a new collapseable grouo - SQLite explorer
// we can right click to tables - show table

// DataContext.cs overrides
// this override the base OnModelCreating method and it return void/nothing
//  protected override void OnModelCreating(ModelBuilder builder)

// this way when we have migration we can insert data into table (value entity is assigned to values table)
// and we can insert automatically more item into values table when we run with next command
//        protected override void OnModelCreating(ModelBuilder builder)
//        {
//            builder.Entity<Value>()
//                .HasData(
//                    new Value { Id = 1, Name = "Value 102" },
//                    new Value { Id = 2, Name = "Value 202" },
//                    new Value { Id = 3, Name = "Value 302" },
//                    new Value { Id = 4, Name = "Value 402" }
//                );
//        }

// we create a new migration (20200218164651_SeedValues) and in this one we seed the values into 'values' table
// note this create insert query's in migration and not add into database
dotnet ef migrations add SeedValues -p Persistence/ -s API/

// values will be inserted in this point when we start our webapi (API)
cd API/
dotnet watch run

// NOTE 1: Dependecy injection in controller
// we make dependency injection in controller too (ValuesController.cs)
// we create new method with classname and inport Persistence project
// here we injected our data context and created private property to save it
//        private readonly DataContext context;
//        public ValuesController(DataContext context)
//        {
//            this.context = context;
//        }

// NOTE 2: vsc private variable prefix
// settings -> search private -> prefix private member declarations

// NOTE 3: don't need this in constructor if the property name exist (ex. with underscore)
//         private readonly DataContext _context;
//        public ValuesController(DataContext context)
//        {
//            _context = context;
//        }

// NOTE 4: - Return data from Db - Async and Task - ToListAsync() and FindAsync(id)
// why use async? it doesn't block the code flow,m it will be executed in different thread
// we convert this in ValuesController.cs
//        public ActionResult<IEnumerable<string>> Get()
//        {
//            return new string[] {"value1", "value2"};
//        }
// to this (and ofc include the entity - Value, from Domain project)
// we wrap the returned type with Task type (similiar like Promise<T> in js)
//  public ActionResult<IEnumerable<string>> Get() => public async Task<ActionResult<IEnumerable<Value>>> Get()
// also we need change the sync code to async:
// var values = _context.Values.ToList(); => var values = await _context.Values.ToListAsync(); // for this we also must import ef core
// return Ok(values); - return http response with code 200 instead of normal value
// await _context.Values.FindAsync(id); - FindAsync use the primary key and return null if not exist

// NOTE 5. Added Cors support in API/Startup.cs - ConfigureService
//            services.AddCors(opt =>
//            {
//                opt.AddPolicy("CorsPolicy", policy => 
//                {
//                    policy.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://172.18.0.2:5000");
//                });
//            });
// and this into Configure method
// app.UseCors("CorsPolicy");


// STEP 4
// Created Domain/Activity.cs - entity and added into DataContext.cs
// create migration for newly created entity
dotnet ef migrations add "ActivityEntityAdded" -p Persistence/ -s API/

// created Seed.cs with SeedData method with a different technique to seed data into database 
// then execute at web api start if no data in table with API/Program.cs - Main - scope where we jave access to context

// INSTALL: in vsc - nuget add package: MediatR.Extensions.Microsoft.DependencyInjection

// --- MEADIATOR/MediatR LOGIC --- motto is keep controller dumb/slim and each method have only 1 responsibility (receive request and send back the response from mediator)
// - create our handler into Application/Activities/List.cs where we inject domain and persistence, here we inject the DataContext and make the async query in database
// - create our controller into API/Controllers/ActivitiesController.cs but this time instead of DataContext we inject our mediator from Application/Activities folder
// our new get from controller use List method from the mediator
// ex: public async Task<ActionResult<IEnumerable<Activity>>> List()
// - inject mediator into Startup.cs into dependency injection container (ConfigureServices), \
// ex.: services.AddMediatR(typeof(List.Handler).Assembly);
// List.Handler is comming from Application/Activities/List.cs - Handler class in List class (so we must import that too with MediatR into StartUp.cs)
