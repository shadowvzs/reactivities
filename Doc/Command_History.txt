// we use class library, web api and solution
// separation:
// API - controllers
// Application - business logic/Error/Exception catcher/Interfaces
// Persistence - database logic
// Infrastructure - jwt

// check availaible templates for dot net cli
dotnet new -h

// create new solution file - file name will be same than the parent folder name
// its like a container for dotnet application
dotnet new sln

// create class library with name, this create folder and files into Domain folder
// ex: Domain.csproj, Class1.cs, obj folder)
// each project have his own csproj file (obj folder used when project will be built)
dotnet new classlib -n Domain

dotnet new classlib -n Application
dotnet new classlib -n Persistence

// we create web api 
dotnet new webapi -n API

// check the options like: 
// add <project_path> - add/insert one or more project into solution
// list - list all projects in a solution file
// remove <project_path> - remove on or more project from the solution file
dotnet sln -h

// add Domain project into main solution
dotnet sln add Domain/
dotnet sln add Application/
dotnet sln add Persistence/
dotnet sln add API/

// we list in terminal which projects was added (ex. first row: Domain/Domain.csproj)
dotnet sln list

// lets make dependencies, ex. Applicaiton depend on Domain project
cd Application/
dotnet add reference ../Domain/
// Application project must depend also on Persistence project
dotnet add reference ../Persistence/

// we make Api depend on Application and indirectly this way we depend on Domain too
cd ..
cd API/
dotnet add reference ../Application/

// persistence project also depend on domain project
cd ..
cd Persistence
dotnet add reference ../Domain/

// Note 1: -csproj files
// csproj file contain:
// - the required dotnet version (ex. netstandard2.0 or netcoreapp3.1)
// - project reference dependencies
// - on which was built (ex. <Project Sdk="Microsoft.NET.Sdk"> or <Project Sdk="Microsoft.NET.Sdk.Web">)


// Note 2: - VSC exclude
// in visual studio code we should add the bin/obj folders into exclude 
// File/Preferences/Settings/exclude (in searchbar) and add **/bin and **/obj

// Note 3: - Program.cs
// API/Program.cs - Main handle the web api part with the routes 
// it will call CreateHostBuilder(args).Build().Run() - IHostBuilder interface
// - load json files with the configuration
// - use the kestrel web server
// - use the StartUp class (it is in same folder, StartUp.cs), we can inject here our configuration
// - ConfigureServices is the dependency injection container
// - Configure method is used for configure the HTTP request pipeline, like we can add middlewate (so ordering important here)
//      - example UseHttpsRedirection should redirect http to https - this should be commented out in our case
//      - ACTION: comment out UseHttpsRedirection
//                 - UseRouting is for middleware and UseAuthorization for auth, UseEndPoints is controller endpoints maping

// Note 4: - launchSettings
// API/Properties/launchSettings.json tell which url use the web api endpoints (http and https)
// ex. "applicationUrl": "https://localhost:5001;http://localhost:5000",
// ACTION: we remove our https endpoint

// Note 5: - Controllers
// by default we got an example controller in API/Controllers/WeatherForecastController.cs
// ACTION: we delete this controller: API/Controllers/WeatherForecastController.cs and Api/WeatherForecast.cs
// Action: create new file into API/Controllers - ValuesController.cs and copy pasted a base (base_ctrl.txt)
// [Route("api/[controller]")] - create a new route and [controller] part replaced with controller name ex. api/values
// [HttpGet] method decorator and the decorated method will handle the  api/values url request
// [HttpGet("{id}")] will match the methods like api/values/5 and in method the param name is id
//          ex: public ActionResult<string> Get(int id) { return "something string"; }
// return an array of string should be:
//                 return  new string[] { "value1", "value2" };

// NOTE!!: We use ControllerBase and not Controller for extend our controller because ControllBase not have view support unlike Controller have

// run a specific project, and we should check this in browser: http://localhost:5000/api/values
dotnet run -p API/


// Note 1: Domain class
// rename Domain/Class1.cs to Value.cs (rename the class to in the file)
// file the Value.cs with properties like id and name

// Note 2: Data Context - road to entity framework
// in Persistence folder we rename the class file and class name to DataContext

// Note 3: Add entity framework
// ctrl + shift + p in vsc (if nuget package manager plugin is installed) 
// select nuget add package
// package name is (both must have same version):
//   - Microsoft.EntityFrameworkCore.Core
//   - Microsoft.EntityFrameworkCore.Design
//   - Microsoft.EntityFrameworkCore.Sqlite
// select Persistence.csproj

// Note 4: EntityFramework need higher .net dependency
// change netstandard2.0 in Persistence.csproj to netstandard2.1

// check dependency
dotnet restore

// this tell to us we need same version (2.1) dependency in Domain.csproj and in Application.csproj too

// check dependency
dotnet restore

// Note 5: add EFCore into DataContext
// add "using Microsoft.EntityFrameworkCore;" to DataContext.cs
// then we start work on this file ( add constructor, db options)

// public DataContext(DbContextOptions options) : base(options) - copnstructor which use the base constructor
// public DbSet<Value> Values { get; set; }
//  - Value is entity (also need import with using the project where is the entity like "using Domain;")
//  - Values - will be table name

// Note 6: Service injection into service container
// in API/startup.cs - ConfigureServices we must add our DbContext above service.AddControllers();
//            service.AddDbContext<DataContext>(opt => 
//            {
//                // we inject our connection string from the configuration what we have in Startup method
//                opt.UseSqlite(Configuration.GetConnectionString("DefaultConnection"));
//            });
// we must import it from the Persistence project and Microsoft.EntityFrameworkCore

// Note 7: Connection string
// we can specify the ConnectionStrings in API/appsettings.json
// something like this for Sqlite:
//    "ConnectionStrings": {
//        "DefaultConnection": "Data source=reactivities.db"
//    },

// install dotnet entity framework globally
dotnet tool install --global dotnet-ef
// or local install
dotnet new tool-manifest
dotnet tool install --local dotnet-ef
// this fix the error with unknown command
// dotnet tool install --global dotnet-ef --version 3.1.2
// dotnet tool restore // for make the dotnet ef command active

// test the installed version
dotnet ef

// we create a initial migration with name InitialCreate (will be in Persistence/Migrations/20200217202915_InitialCreate.cs)
// also we must set with -p the dataContext project (Persistence)
// and the startup project (API/)
dotnet ef migrations add InitialCreate -p Persistence/ -s API/

// Note 1: table creation rule
// entity framework is convention base, so if i declared id then that will be automatical primary key with auto increment
// the table name (we get it from Persistence/DataContext - DbSet) 
// columns are based on Domain/Value.cs (because we used -p Persistence/ and DataContext is the glue between entities and final table)

// get the entity framework options
dotnet ef -h
dotnet ef database -h

// we should update database with: dotnet ef database update
// but we want make it during every program start so we will add into Program.cs

// Note 1: create scope into method
// the example below will be cleaned up instantly the main function will be done
// this will need Microsoft.Extensions.DependencyInjection;
// using (var scope = host.Services.CreateScope()) { ... }

// Note 2: Create/Update database at project start
// API/Program.cs we create a new var into Main()  and we can use Run() later
// var host = CreateHostBuilder(args).Build(); 

// !!! Note 3: watch run and restriction !!!
// watch run work only if we are in startup project 
dotnet watch run

// Note 3: Debug Sqlite with vsc (sqlite extension)
// ctrl+shift+p (view -> command pallette)
// sqlite -> open database and select database
// then we will have in left sidepanel a new collapseable grouo - SQLite explorer
// we can right click to tables - show table

// DataContext.cs overrides
// this override the base OnModelCreating method and it return void/nothing
//  protected override void OnModelCreating(ModelBuilder builder)

// this way when we have migration we can insert data into table (value entity is assigned to values table)
// and we can insert automatically more item into values table when we run with next command
//        protected override void OnModelCreating(ModelBuilder builder)
//        {
//            builder.Entity<Value>()
//                .HasData(
//                    new Value { Id = 1, Name = "Value 102" },
//                    new Value { Id = 2, Name = "Value 202" },
//                    new Value { Id = 3, Name = "Value 302" },
//                    new Value { Id = 4, Name = "Value 402" }
//                );
//        }

// we create a new migration (20200218164651_SeedValues) and in this one we seed the values into 'values' table
// note this create insert query's in migration and not add into database
dotnet ef migrations add SeedValues -p Persistence/ -s API/

// values will be inserted in this point when we start our webapi (API)
cd API/
dotnet watch run

// NOTE 1: Dependecy injection in controller
// we make dependency injection in controller too (ValuesController.cs)
// we create new method with classname and inport Persistence project
// here we injected our data context and created private property to save it
//        private readonly DataContext context;
//        public ValuesController(DataContext context)
//        {
//            this.context = context;
//        }

// NOTE 2: vsc private variable prefix
// settings -> search private -> prefix private member declarations

// NOTE 3: don't need this in constructor if the property name exist (ex. with underscore)
//         private readonly DataContext _context;
//        public ValuesController(DataContext context)
//        {
//            _context = context;
//        }

// NOTE 4: - Return data from Db - Async and Task - ToListAsync() and FindAsync(id)
// why use async? it doesn't block the code flow,m it will be executed in different thread
// we convert this in ValuesController.cs
//        public ActionResult<IEnumerable<string>> Get()
//        {
//            return new string[] {"value1", "value2"};
//        }
// to this (and ofc include the entity - Value, from Domain project)
// we wrap the returned type with Task type (similiar like Promise<T> in js)
//  public ActionResult<IEnumerable<string>> Get() => public async Task<ActionResult<IEnumerable<Value>>> Get()
// also we need change the sync code to async:
// var values = _context.Values.ToList(); => var values = await _context.Values.ToListAsync(); // for this we also must import ef core
// return Ok(values); - return http response with code 200 instead of normal value
// await _context.Values.FindAsync(id); - FindAsync use the primary key and return null if not exist

// NOTE 5. Added Cors support in API/Startup.cs - ConfigureService
//            services.AddCors(opt =>
//            {
//                opt.AddPolicy("CorsPolicy", policy => 
//                {
//                    policy.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://172.18.0.2:5000");
//                });
//            });
// and this into Configure method
// app.UseCors("CorsPolicy");


// STEP 4
// Created Domain/Activity.cs - entity and added into DataContext.cs
// create migration for newly created entity
dotnet ef migrations add "ActivityEntityAdded" -p Persistence/ -s API/

// created Seed.cs with SeedData method with a different technique to seed data into database 
// then execute at web api start if no data in table with API/Program.cs - Main - scope where we jave access to context

// INSTALL: in vsc - nuget add package: MediatR.Extensions.Microsoft.DependencyInjection

// --- MEADIATOR/MediatR + CQRS (command and query) LOGIC --- motto is keep controller dumb/slim and each method have only 1 responsibility 
// receive request and send back the response from mediator also controller cannot know anymore about the logic, it is just responsible to repond to http request and each individual part should be updated without make any issue

// - create our handler into Application/Activities/List.cs where we inject domain and persistence, here we inject the DataContext and make the async query in database
// - create our controller into API/Controllers/ActivitiesController.cs but this time instead of DataContext we inject our mediator from Application/Activities folder
// our new get from controller use List method from the mediator
// ex: public async Task<ActionResult<IEnumerable<Activity>>> List()
// - inject mediator into Startup.cs into dependency injection container (ConfigureServices), 
// ex.: services.AddMediatR(typeof(List.Handler).Assembly);
// NOTE 1: List.Handler is comming from Application/Activities/List.cs - Handler class in List class (so we must import that too with MediatR into StartUp.cs)
// NOTE 2: we need add mediator only once because our type will be same for every handler (List, Details etc all got same structure)

// we create Details.cs into Application/Activities with similiar way like List.cs except here we use Activity type instead of List<Activity> and in query we have a param
// we create new method into controller for getting only 1 value, ex:
//        [HttpGet("{id}")]
//        public async Task<ActionResult<Activity>> Details(Guid id)
//        {
//            return await _mediator.Send(new Details.Query{Id = id} );
//        }  

// IRequestHandler<Query, User> - First is the type Query or Command (we use same method name below with the logic) and 2nd type which will returned

// CANCELLATIONTOKEN - used for abort the request if user click to something which takes alot time then use click to cancel/stop in browser
// ex heavy math calculations or database query is stopable in this case
// first we must propagate the cancellationToken from controller to mediator
// API/Controllers/ActivitiesController.cs
// public async Task<ActionResult<List<Activity>>> List(CancellationToken ct)
// {
// return await _mediator.Send(new List.Query(), ct);
// }
// Applications/Activity/List.cs
// ex. var activities = await _context.Activities.ToListAsync(cancellationToken);
// or manually we thrown exception which we should catch
// try {
// cancellationToken.ThrownIfCancellationRequested();
// } catch (Exception ex) when (ex is TaskCancelException) { ... }

// LOGGER - useage of terminal logger
// inject into constructor like: 
// public Handler(DataContext context, ILogger<List> logger) - List is the class which want log and import Microsoft.Extensions.Logging;
// { var i = 2; logger.LogInformation($"Task {i} completed"); }

// create Create.cs mediator into Application/Activities/ - Command mediator which have few differences vs Query like Handler returning type is Unit
// we use Add instead of AddAsync (because the recommandation is we can use sync Add everytime except some secial case when we must generate few thing)
//                 _context.Activities.Add(activity);
//                var success = await _context.SaveChangesAsync() > 0; 
// SaveChangesAsync() return Task<int> - this int is nr of changes saved into db. if it is 0 then not was added to db
//                if (success) return Unit.Value; // empty object but return resp. code 200

// CONTROLLER - REQUEST BODY - POST/PUT
// if we use [ApiController] then don't need to specify the [FromBody] (ex. public async Task<ActionResult<Unit>> Create([FromBody] Activity dto) )
// we can use directly the mediator command handler

// STEP 4: video 45 - about creatting custom snippet for vscode for make faster the implementing mediator command class

// Added Edit.cs and created the edit mediator and method for edit controller
// Added Delete.cs and created the delete mediator and method for edit controller

// drop database
dotnet ef database drop -p Persistence/ -s API/ 


// Step 10: E122 - SIMPLE SERVER SIDE ENTITY VALIDATION / Data Annotation validation for entity, in Application/Activities/Create.cs in Command
// adding decorator for property like [Required] and this will automatical thrown error code 400 with correct error message in response
// Reason why automatical validated and sent error if validation fail is because we use [ApiController] in ActivitiesController.cs


// VSC DOTNET DEBUGGER
// 1. - in launch.json must have the following lines for debugger:
//        {
//             "name": ".NET Core Attach",
//             "type": "coreclr",
//             "request": "attach",
//             "processId": "${command:pickProcess}"
//        }
// 2. - select a breakpoint in vsc (that red dot at left side)
// 3. - we must go to left side debug tab and select ".NET Core Attach" on top-left corner
// 4. - we must select API.dll
// 5. - comment out the [ApiController] decorator from  controller which we want debug (ex. ActivitiesController.cs)
// 6. - make request and now we will see the variables inside the Variables box (ex. this, command)
// 7. - validation error is in: this/ModelState (we have more prop here like Count, ResultView[0].Key and Value.Errors[0].ErrorMessage)
//   full path for error message is something like this:  this.ModelState.ResultView[0].Value.Errors[0].ErrorMessage

// VALIDATION HANDLING - Application/Activities/Create.cs - async Create method ex.:
// if (!ModelState.isValid) { return BadRequest(ModelState); before the meditor send method calling

// FLUENT VALIDATION - we use this which act like middleware between our mediator command and handler
// NOTE: only netstandard2.0 and netcoreapp3.0 is compatible with this package so we must change in Application.csproj
// but we must do same for all class libs (Domain, Persistence 
// ----- then dotnet restore -----
// we must go to view -> command palette -> nuget package manager: add package in vsc:
// FluentValidation - FluentValidation.AspNetCore and install into Application project because there is our mediator handlers/business logic too
// in mediator (ex. Application/Activities/Create.cs) we create a public class for this with CommandValidator name
// ex.: public class CommandValidator : AbstractValidator<Command> // in this case we walidate the command class so thats why we add Command into <>
// we must create constructor for it
// and we must add into start class - Startup.cs and change this:
// services.AddControllers(); => services.AddControllers().AddFluentValidation(cfg => 
// {
//  cfg.RegisterValidatorsFromAssemblyContaining<Create>();
// };

// NOTE !!!: PACKAGE COMPATIBILITY
// if installed package not compatible with the dotnet version then simple give error when we try to add to "using"-s and VSC doesnt give hint to implement it

// Validation on Controller level:
// sometimes we want return notFound error if entity isn't found then we can check if value is null and if yes we can return NotFound(); - not fund error
// we can create our own Exception handler (ex. Applications/Errors/RestException.cs which extends the Exception class)

// Exception middleware for REST:
// we create middleware in web api folder which according the ms advice should be the last middleware in Startup.cs (ex. /API/Middleware/ErrorHandlingMiddleware.cs)
// in our case we comment out app.UseDeveloperExceptionPage(); from Startup.cs, we insert our middleware into first place in Configure method
// app.UseMiddleware<ErrorHandlingMiddleware>();
// after this in mediator handler we should use RestException, so instead of throw Exception('...'); we will use: throw RestException('...');
// and we need import the error handlers "using Application.Errors;"


// Step 12: - Identify
// we create class for identity user (Domain/AppUser.cs)
// we install Microsoft.AspNetCore.Identity.EntityFrameworkCore in nuget package manager
// we replace the DbContext type at DataContext class to IdentityDbContext<AppUser> (and using the above lib)
// because we declared the AppUser above we dont need DbSet like we used for Value and Activity in this class
// we will add base.OnModelCreating(builder); into OnModelCreating method which allow us to create migration
// we add migration: 
dotnet ef migrations add "AddedIdentity" -p Persistence/ -s API/

// we also need to a Microsoft.AspNetCore.Identity.UI 3.0.0 - sider manager and we install into API
// we must add into Startup.cs - ConfigureServices like other things
// !!NOTE!!: for MVC services.AddIdentity (ex. for blazzer) and services.AddIdentityCore for backend
// var build = services.AddIdentityCore<AppUser>();                                           // for AppUser we must import Domain into StartUp.cs
// var identityBuilder = new IdentityBuilder(builder.UserType, builder.Services);             // need to import Microsoft.AspNetCore.Identity
// identityBuilder.AddEntityFrameworkStores<DataContext>();                                   // inject ef
// identityBuilder.AddSignInManager<SignInManager<AppUser>>();                                // inject sign in manager
// services.AddAuthentication();

// Seed users into database
// Persistence/Seed.cs
// if (!userManager.Users.Any())
//            {
//                var users = new List<AppUser>()
//                {
//                    new AppUser
//                    {
//                        DisplayName = "Bob",
//                        UserName = "bob",
//                        Email = "bob@test.com" 
//                    }
//                }
//            }
// userManager.CreateAsync(users[0], "Pa$$w0rd"); // this will save into dtabase and dont need saveChanges too
// because we use async method we also must convert void return type to async Task
// public static void SeedData(DataContext context) => public static async Task SeedData(DataContext context, UserManager<AppUser> userManager)
// then we must add the userManager to Seed.SeedData from Program.cs
// var userManager = services.GetRequiredService<UserManager<AppUser>>();
// Seed.SeedData(context, userManager).Wait();
// NOTE: if have Exited with error code 134 then we must go to StartUp.cs and add services.AddAuthentication();


// Step 12: Login handler
// we create a login handler mediator into Application/User/Logic.cs - query like with email and password, fluent validation and password check
// we create a base controller for aable to handle user/auth thing in other controllers
// in base controller if mediotr not exist then we will initiate (need Microsoft.Extensions.DependencyInjection for this)
//       private IMediator _mediator;
//       protected IMediator Mediator => _mediator ?? (_mediator = HttpContext.RequestServices.GetService<IMediator>())

// create User model which we will return to frontend, into Application/User/User.cs and returnUser types in every handle in Login.cs
// Create infrastructure project which will be responsible for jwt validation and creation
dotnet new classlib -n Infrastructure
// add Infrastructure to solution and change the new project dependency (csproj) to netcoreapp3.0
dotnet sln add Infrastructure/
// we need add reference to Application (where is our mediator), so application project will be dependency for infrastructure project
cd Infrastructure
dotnet add reference ../Application/
// addreference/deoebdebcy for API too
cd ..
cd API
dotnet add reference ../Infrastructure/
// we create interface for jwt into Application/interfaces/IJwtGenerator.cs
// we create the jwt generator class into Ifrastructure/Security/JwtGenerator.cs (also we import the interface)
// we must insert this service into startUp class, well the interface only (ofc we must import Infrastructure.Security and Application.Interfaces)
// services.AddScoped<IJwtGenerator, JwtGenerator>();


// Step 12: install JWT package, System.IdentityModel.Tokens.Jwt into Infrastructure project
// in JwtGenerator class we use:
// Claim list (we save id and name into token)
// security key with SymmetricSecurityKey (server side secret key)
// credentials with SigningCredentials (aram is key and security algorithm)
// token descriptor:
//     subject with claims[user data in token]
//     expires[Date.Now.AddDays(7)]
//     SigningCredentials[creds/signing credetials from above]
// init token handler (JwtSecurityTokenHandler)
// create token with this token handler from tokenDescriptor
// writeToken with tokenhandler where param is the token and return it

// The cool thing if we must use this then we need only import the namespace for interface where we declared the interface, example for accesing 
// the jwtGenerator we need import only the Application.Interfaces and not the Infrastructure.Security where is our generator
// public Handler(UserManager<AppUser> userManager, SignInManager<AppUser> signInManager, IJwtGenerator jwtGenerator)


// Step 12: Authentication
// for jwt authentication we must install Microsoft.AspNetCore.Authentication.JwtBearer 3.0.0 into API
// in Startup.cs at ConfigureServices we need to inject the athentication with JWT (we must import the above package)
//            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
//                .AddJwtBearer(opt =>
//                {
//                    opt.TokenValidationParameters = new TokenValidationParameters
//                    {
//                        ValidateIssuerSigningKey = true,
//                        IssuerSigningKey = key,
//                        ValidateAudience = false,
//                        ValidateIssuer = false
//                    };
//                });

// At configure we must order our middlewares
//  app.UseAuthentication(); // must be after routing, cors but before the endpoints and UseAuthorization

// Step 12: protecting controller / endpoints 
// with [Authorize] decorator (after Http decorator) - using Microsoft.AspNetCore.Authorization;
// so if user have no valid jwt then will get 401 - unauthorized error


// Step 12: Secret 
// !!! NOTE !!! this will be stored in development machhine and not on the source code!!!
// we can generate secret (a value pair example for jwt secret key)
dotnet user-secrets init -p API/
// this will generate something like this: Set UserSecretsId to '42cbc11c-9b17-4bc1-8121-8ba488e6593b' for MSBuild project '/home/shared/Reactivities/API/API.csproj'.
// this will be added into API.csproj file like:     <UserSecretsId>42cbc11c-9b17-4bc1-8121-8ba488e6593b</UserSecretsId>

// for generate secret we will use dotnet user-secrets set "KEY" "VALUE" -p PROJECT/
dotnet user-secrets set "TokenKey" "hurka gyurka asdasd" -p API/

// we can list the existing secrets with (same way we have remove too)
dotnet user-secrets list -p API/


// Step 12: using secret for authetntication jwt key
// NOTE: Secret key must be minimum 16 byte, cannot be less else we get the following error: IDX10603: Decryption failed. Keys tried: [PII is hidden]
// if we go to startup.cs then we should replace the static key (below)
// var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("Super secret key"));
// to (below) - note we have access to Configuration because we assigned to StartUp class
//       public Startup(IConfiguration configuration)
//        {
//            Configuration = configuration;
//        }
// .........................
// var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration["TokenKey"]));

// we also must inject the configuration into JwtGenerator constructor (using Microsoft.Extensions.Configuration;)
//        private readonly SymmetricSecurityKey _key;
//        public JwtGenerator(IConfiguration config)
//        {
//            _key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config["TokenKey"]));
//        }


// Step 12: Authorization policy - instead of force muanlly each controller endpoint to have authorize with decorator, we check authentication automatically for every endpoint
// in Startup.cs we must make some logic when we AddController to services
//            services.AddControllers() 
// we make a lambda function and add authorizationPolicy (using Microsoft.AspNetCore.Mvc.Authorization;)
//            services.AddControllers(opt =>
//            {
//                var policy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();
//                opt.Filters.Add(new AuthorizeFilter(policy));
//            })

// LOGIN - AUTHORIZATION EXCEPTION, for login we dont need to check if user is authorized
// in UserController.cs we will use [AllowAnonymous] decorator for login or for the whole class

// Step 12: Registration - Exception Command Mediator when we return back something even it is Command and not query mediator
// We create Register.cs command mediator into Application/User folder
// we create register method into UserController

// Step 12: Custom validator - we create a Password validator which have multiple rule and reusable
// we create Application/Validators/ValidatorExtensions (static class) for handle the password validation (will have min length, need mixed upper lower case letters etc)
// then in Register function we use .Password() same way like NonEmpty() but this is an extension

// Step 12: GetCurrentUsername
// we create Application/Interface/IUserAccessor.cs interface
// we create Infrastructure/Security/UserAccessor.cs class
// here we inject the IHttpContextAccessor and access the name with:
// var username = _httpContextAccessor.HttpContext.User?.Claim?.FirstOrDefault(x => x.Type == ClaimTypes.NameIdentifier)?.Value;
// at Startup.cs we must inject our interface and class services.AddScoped<IUserAccessor, UserAccessor>(); so we can use anywhere if we inject it into constructer the IUserAccessor

// Step 12: getting the CurrentUser - logged user
// create Application/User/CurrentUser.cs - query handler - use userManager, jwtGenerator
// add method for UserController too
// Note in controller since we dont provide params then we leave empty () after CurrentUser method name and return this way:
// return await Mediator.Send(new CurrentUser.Query());

// step 14: RELATIONSHIP - ENTITY FRAMEWORK
// we create a relationship between users and activities (many to many) table, Domain/UserActivity.cs
//        public string AppUserId { get; set; }
//        public AppUser AppUser { get; set; }
//        public Guid ActivityId { get; set; }
//        public Activity Activity { get; set; }
//        public DateTime DateJoined { get; set; }
//        public bool isHost { get; set; }

// adjust the AppUser.cs and into Activity.cs with
//        public ICollection<UserActivity> UserActivities { get; set; } // using System.Collections.Generic;

// we must insert also the DbSet for UserActivity in Persistence/DbContext.cs
//  public DbSet<UserActivity> UserActivities { get; set; }
// we declare the foreign keys
//            builder.Entity<UserActivity>(x => x.HasKey(ua => 
//                new { ua.AppUserId, UserActivities.Activity.id}
//            ));
// then we made 2 relationships:
//            builder.Entity<UserActivity>()
//                .HasOne(u => u.AppUser)
//                .WithMany(a => a.UserActivities)
//                .HasForeignKey(u => u.AppUserId);
//            builder.Entity<UserActivity>()
//                .HasOne(a => a.Activity)
//                .WithMany(u => u.UserActivities)
//                .HasForeignKey(a => a.ActivityId); 

// we do migration
dotnet ef migrations add "UserActivityAdded" -p Persistence/ -s API/

// step 14: Save and load related entities
// Application/Activities/Create.cs we must save the relations too, we can do that because we can access the username with IUserAccessor and save into UserActivities
//                var user = await _context.Users.SingleOrDefaultAsync(x => 
//                    x.UserName == _userAccessor.GetCurrentUsername());
//                var attendee = new UserActivity
//                {
//                    AppUser = user,
//                    Activity = activity,
//                    isHost = true,
//                    DateJoined = DateTime.Now
//                };
//                _context.UserActivities.Add(attendee);

// Load the related entities (we use eager loading):
// we have 3 option (https://docs.microsoft.com/en-us/ef/core/querying/related-data):
//    - eager loading - load together with main query (.Include(x => x.RelatedEntity))
//    - explicit loading - explicitly loaded from the database at a later time
//    - lazy loading - related data loaded from db when navigation property is accessed
// in Application/Activities/List.cs
//   var activities = await _context.Activities.ToListAsync(); 
// became
//                var activities = await _context.Activities
//                    .Include(x => x.UserActivities)
//                    .ThenInclude(x => x.AppUser)
//                    .ToListAsync();
// NOTE: FindAsync isn't support the relationships, for that we must use SingleOrDefaultAsync
// NOTE: We need fix the self referencing loops (activity -> useractivity->appuser->activity [<--- this is same than initial activity])
